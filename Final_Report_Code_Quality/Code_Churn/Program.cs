using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading.Tasks;
using Octokit;

/* 
   This program analyzes code churn (additions/deletions) per folder 
   in the Home Assistnant Core GitHub repository over a specified time window.
   It uses the Octokit library to interact with the GitHub API.
   This code was generated by extending code generated by ChatGPT.
*/
class Program
{
    // Aggregation bucket
    private sealed class Churn
    {
        public long Additions { get; set; }
        public long Deletions { get; set; }
        public long FilesTouched { get; set; }
        public long CommitsTouched { get; set; }
        public long Total => Additions + Deletions;
    }

    static async Task Main(string[] args)
    {
        // ----- Config -----
        string owner = GetArg(args, "--owner", "home-assistant");
        string repo = GetArg(args, "--repo", "core");

        // Time window (defaults: last 30 days)
        DateTimeOffset until = ParseDate(GetArg(args, "--until", ""), DateTimeOffset.UtcNow);
        DateTimeOffset since = ParseDate(GetArg(args, "--since", ""), until.AddDays(-1));

        // Folder grouping depth: 1 = top-level, 2 = two segments, etc.
        int folderDepth = int.TryParse(GetArg(args, "--depth", "1"), out var d) ? Math.Max(1, d) : 1;

        string token = "TOKEN";
        if (string.IsNullOrWhiteSpace(token))
        {
            Console.Error.WriteLine("Please set GITHUB_TOKEN env var (fine-grained PAT with repo read access).");
            return;
        }

        var client = new GitHubClient(new ProductHeaderValue("ChurnPerFolder"))
        {
            Credentials = new Credentials(token)
        };

        Console.WriteLine($"Repository: {owner}/{repo}");
        Console.WriteLine($"Window:    {since:u}  →  {until:u}");
        Console.WriteLine($"Depth:     {folderDepth}");
        Console.WriteLine();

        // ----- Get commits in window (paged) -----
        var commitRequest = new CommitRequest
        {
            Since = since,
            Until = until
        };

        var options = new ApiOptions
        {
            PageSize = 100,
            PageCount = 1,     // will loop until no more results
            StartPage = 1
        };

        var churnByFolder = new Dictionary<string, Churn>(StringComparer.OrdinalIgnoreCase);

        int commitsFetched = 0;
        int page = 1;

        while (true)
        {
            options.StartPage = page;

            var commits = await client.Repository.Commit.GetAll(owner, repo, commitRequest, options);
            if (commits.Count == 0) break;

            foreach (var c in commits)
            {
                // For each commit, fetch detailed stats including file-level additions/deletions
                var details = await client.Repository.Commit.Get(owner, repo, c.Sha);
                var files = details.Files ?? new List<GitHubCommitFile>();
                var foldersTouchedInThisCommit = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

                foreach (var f in files)
                {
                    // Skip binary/large files if needed:
                    // if (string.Equals(f.Status, "renamed", StringComparison.OrdinalIgnoreCase)) continue;

                    var key = FolderKey(f.Filename, folderDepth);

                    if (!churnByFolder.TryGetValue(key, out var agg))
                    {
                        agg = new Churn();
                        churnByFolder[key] = agg;
                    }

                    agg.Additions += f.Additions;
                    agg.Deletions += f.Deletions;
                    agg.FilesTouched += 1;

                    if (foldersTouchedInThisCommit.Add(key))
                    {
                        agg.CommitsTouched += 1;
                    }
                }

                commitsFetched++;
            }

            page++;
        }

        // ----- Print results -----
        var rows = churnByFolder
            .Select(kv => new
            {
                Folder = kv.Key,
                kv.Value.Additions,
                kv.Value.Deletions,
                Total = kv.Value.Total,
                kv.Value.FilesTouched,
                kv.Value.CommitsTouched
            })
            .OrderByDescending(r => r.Total)
            .ToList();

        Console.WriteLine($"Commits analyzed: {commitsFetched}");
        Console.WriteLine();
        Console.WriteLine("Folder,Additions,Deletions,TotalChurn,FilesTouched,CommitsTouched");

        foreach (var r in rows)
        {
            Console.WriteLine($"{Csv(r.Folder)},{r.Additions},{r.Deletions},{r.Total},{r.FilesTouched},{r.CommitsTouched}");
        }

        Console.WriteLine();
        Console.WriteLine("Tip: redirect output to a CSV file:");
        Console.WriteLine("  dotnet run -- --owner home-assistant --repo core --since 2025-09-01 --until 2025-10-01 --depth 1 > churn_per_folder.csv");
    }

    // ----- Helpers -----

    static string GetArg(string[] args, string name, string fallback)
    {
        var i = Array.IndexOf(args, name);
        if (i >= 0 && i + 1 < args.Length) return args[i + 1];
        return fallback;
    }

    static DateTimeOffset ParseDate(string s, DateTimeOffset fallback)
    {
        if (string.IsNullOrWhiteSpace(s)) return fallback;
        if (DateTimeOffset.TryParse(s, CultureInfo.InvariantCulture, DateTimeStyles.AssumeUniversal, out var dt))
            return dt.ToUniversalTime();
        return fallback;
    }

    static string FolderKey(string path, int depth)
    {
        if (string.IsNullOrWhiteSpace(path)) return "(unknown)";
        var parts = path.Split(new[] { '/', '\\' }, StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length == 0) return "(root)";
        var take = Math.Min(depth, parts.Length - 1); // folder segments, not including file
        if (take <= 0) return parts.Length > 1 ? parts[0] : "(root)";
        return string.Join("/", parts.Take(take));
    }

    static string Csv(string s)
    {
        if (s == null) return "\"\"";
        return "\"" + s.Replace("\"", "\"\"") + "\"";
    }
}
